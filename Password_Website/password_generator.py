12# -*- coding: utf-8 -*-
"""Password_Generator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sfzATcatPK05dB3ksolqd3rVYrXrOshJ
"""

import random
import string

def generate_strong_password(length=12):
    """
    Generate a strong password with a given length.

    Parameters:
    - length (int): Length of the password (default is 12)

    Returns:
    - str: Strong password
    """
    # Define character sets for different types of characters
    lowercase_letters = string.ascii_lowercase
    uppercase_letters = string.ascii_uppercase
    digits = string.digits
    special_characters = string.punctuation

    # Combine character sets
    all_characters = lowercase_letters + uppercase_letters + digits + special_characters

    # Ensure at least one character from each set is included
    password = [
        random.choice(lowercase_letters),
        random.choice(uppercase_letters),
        random.choice(digits),
        random.choice(special_characters),
    ]

    # Generate remaining characters randomly
    for _ in range(length - 4):
        password.append(random.choice(all_characters))

    # Shuffle the characters to make the password more secure
    random.shuffle(password)

    # Convert the list of characters to a string
    strong_password = ''.join(password)

    return strong_password

# Generate strong password for user
password = generate_strong_password()
print("Generated Strong Password:", password)

import string

def password_strength_feedback(password):
    """
    Provide feedback about a password's strength.

    Parameters:
    - password (str): Password to evaluate

    Returns:
    - str: Feedback message
    """
    # Criteria for password strength
    length_criteria = 8
    uppercase_criteria = 1
    lowercase_criteria = 1
    digit_criteria = 1
    special_character_criteria = 1

    # Check length
    if len(password) < length_criteria:
        return "Weak: Password should have at least {} characters.".format(length_criteria)

    # Check uppercase letters
    if sum(1 for char in password if char in string.ascii_uppercase) < uppercase_criteria:
        return "Weak: Include at least {} uppercase letter(s) in the password.".format(uppercase_criteria)

    # Check lowercase letters
    if sum(1 for char in password if char in string.ascii_lowercase) < lowercase_criteria:
        return "Weak: Include at least {} lowercase letter(s) in the password.".format(lowercase_criteria)

    # Check digits
    if sum(1 for char in password if char in string.digits) < digit_criteria:
        return "Weak: Include at least {} digit(s) in the password.".format(digit_criteria)

    # Check special characters
    if sum(1 for char in password if char in string.punctuation) < special_character_criteria:
        return "Weak: Include at least {} special character(s) in the password.".format(special_character_criteria)

    return "Strong: Password meets the criteria for a strong password."

# Password Strength user imput
user_password = input("Enter a password: ")
feedback = password_strength_feedback(user_password)
print("Password Strength:", feedback)

import math

def time_to_crack_password(password, attempts_per_second=1000000000):
    """
    Calculate the time it would take to crack a password using brute force.

    Parameters:
    - password (str): Password to evaluate
    - attempts_per_second (int): Number of password attempts per second (default is 1 billion)

    Returns:
    - str: Time to crack in years, days, hours, minutes, and seconds
    """
    # Assuming a character set of 72 (26 lowercase + 26 uppercase + 10 digits + 10 special characters)
    character_set_size = 72

    # Calculate the total possible combinations for the given password length
    total_combinations = character_set_size ** len(password)

    # Calculate the time to crack in seconds
    time_to_crack_seconds = total_combinations / attempts_per_second

    # Convert seconds to years, days, hours, minutes, and seconds
    minutes, seconds = divmod(time_to_crack_seconds, 60)
    hours, minutes = divmod(minutes, 60)
    days, hours = divmod(hours, 24)
    years, days = divmod(days, 365)

    return "{:.0f} years, {:.0f} days, {:.0f} hours, {:.0f} minutes, {:.0f} seconds".format(years, days, hours, minutes, seconds)

# Provide feedbeak to user
user_password = input("Enter a password to estimate crack time: ")
crack_time = time_to_crack_password(user_password)
print("Estimated Time to Crack:", crack_time)